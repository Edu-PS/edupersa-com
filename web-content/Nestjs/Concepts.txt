// CLI 
    - command-line interfaces
    
    - Siempre tienen la misma estructura - https://docs.nestjs.com/cli/overview#cli-command-syntax
        nest commandOrAlias requiredArg [optionalArg] [options]
        EJ - nest new my-nest-project --dry-run

// VERSION DE NEST
    - nest -v

// INSTALAR





// @Module
    - Es una configuracion, conjunto de funciones (servicios) y controladores que manejan una parte del sistema
        y permite mantener segmentado el codigo o funcionalidad de la aplicacion.


// @Controller
    - Se encarga de gestionar (por parte del servidor) las peticiones de los clientes.
        @Controller('controller_path') - 'path' indica cual es el subdominio del cual atendera las solicitudes de los clientes. 

    - Se encarga de preparar los datos a devolver (DTO - Data Transfer Object) a los clienes.


// @Provider
    - Es una parte de codigo que realizar una funcion especifica (puede ser microservicio) y que es inyectable.

    - Se utilizan en otra parte del sistema por inyeccion (con la funcion constructor())

    - Las funciones que se necesitan hacer por el controlador se delegan a los providers.


// @Sevice
    - Son micro funciones que vienen delegadas o son necesitadas por el controlador.

    - Es un tipo de provider, ya que presta una funcion especifica al sistema.


// @Inyectable
    - Indica que ese codigo se puede utilizar en otro lugar (ej. un controller)
        utilizando la funcion contructor() mediante la inyeccion de dependencias


// @Get
    - gestiona las peticiones GET de las webs
        @Get('sub_path') - Gestiona con la direccion 'controller_path/sub_path'.

    - Get(':id') - Indica que en este endpoint vamos a recibir un parametro llamado 'id'
        EJ - @Controller('products') -> @Get(':id') -> /products/18 - El valor de id es 18.


// @Param
    - Nos permite recoger los parametros que se pasan en una solicitud al servidor dentro de un GET, PUT, etc.
        EJ - Obtener todos en un objeto.
        @Get(':id/:size')
            findWithSize( @Param() params) {
                return `En esta ruta obtenemos el producto ${params.id}, pero en su tama침o ${params.size}`;
            }
        
        RUTAS: http://localhost:3000/products/11/small o http://localhost:3000/products/27/big

        EJ - Obtener parametros destructurados @Param('nombre_get') nuevo_nombre: type
        @Get(':id')
        find(@Param('id') id: number) {
            return `P치gina del producto ${id}`;
        }

        @Get(':param1'/:param2)
        nombre_funcion(@Param('param1') nombre_nuevo: type, @Param('param2') nuevo_nombre2: type){ 
            Codigo de funcion, llamado al parametro con ${param1} y ${param2}
        }

    - Este considera todo el texto enviado en la solicitud del cliente.


// @Query
    - Permite recoger parametros de la solicitud del cliente pero utilizando el '?' como indicador de comienzo de parametros 
    
    - EJ - /prueba?id:24
            @Get('prueba?')
            async getHello(@Query('id') id: number): Promise<string> {
                return this.appService.getHello(id.toString());
            }


    - Recibe el dato y lo verifica.
        @Get('cars')
        carsQuery(@Query('count', ParseIntPipe) carCount: number) {
            return carCount;
        }


// @Post
    - Sirve para gestionar solicitudes POST de un cliente.


// @Body
    - Sirve para recibir datos del cuerpo (BODY) de la solicitud enviada al servidor por parte del cliente.

    EJ - Recibiendo todos los datos en una sola variable.
    
        @Post()
        createProduct(@Body() body) {
            return `Creo un producto ${body.name} con descripci칩n ${body.description}`;
        }


    EJ - Recibiendo dato por dato

        @Post()
        createProduct(@Body('name') name: string, @Body('description') description: string) {
            return `Creo el producto ${name} con descripci칩n ${description}.`;
        }


// @Column
    @Column('tipo_dato', { length: xx})
        EJ  -   @Column('varchar', { length: 50 })
                name: string;


// Insertar Entidades en otros modulos
    TypeOrmModule.forFeature([Nombre_Entidad])


// @Entity
    -   @Entity("Nombre_Tabla)
        export class "Nombre_Clase" { Definicion de tabla }


    - Entity({
        name: "users",
        engine: "MyISAM",
        database: "example_dev",
        schema: "schema_with_best_tables",
        synchronize: false,
        orderBy: {
            name: "ASC",
            id: "DESC",
        },
    })
    export class User {}



// Pasos para trabajar con bases de datos.

    - Instalar TypeOrm y mysql2 -> npm i @nestjs/typeorm mysql2 typeorm

    - Configurar la conexion de la base de datos en un modulo a parte.
        - Importar TypeOrmModule.forRoot() en el modulo y configurarlo.

    - Crear la entidad de la estructura de la base de datos 
        -> nombre_entidad.entity.ts

    - Crear el controlador, servicio y modulo de la web que va a comunicar con la base de datos.

        - Servicio -> 
            Inyectar el repositorio (Que da acceso a funciones de bases de datos) haciendo referencia a la entidad que se va a utilizar.
            Crear las funciones que se vayan a utilizar en el controlador -> constructor(@InjectRepository(Entity) private readonly nombreLocalRepositorio: Repository<Entity>,) {}
        
        - Controlador -> 
            Inyectar el servicio para llamar a las funciones
            Crear las diferentes rutas que se necesiten manejar constructor(private readonly nombreLocalServicio: ServicioAUtilizar)

        - Modulo -> 
            Importar el modulo de conexion de la base de datos. 
            Importar (imports) las entidades que se vayan a manejar (TypeOrmModule.forFeature([Entity]))
            Para usar esa entidad en otros modulos se tiene que exportar(exports) TypeOrmModule.

    - Importar el modulo que se quiere ejecutar en el modulo principal de la aplicacion.